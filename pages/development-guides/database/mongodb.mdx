import { Tab, Tabs, Callout, Steps } from 'nextra-theme-docs';

# Using ROQ with MongodDB

This guide will provide instructions on how to integrate an application generated by ROQ with a NoSQL database, specifically MongoDB.

## What is MongoDB?

[MongoDB](https://www.mongodb.com/) is a type of database known as NoSQL. It stores data in BSON format, which is similar to JSON and is designed for storing data in key-value pairs. MongoDB is popular in JavaScript application development because its document model is easily mappable to objects in application code. Additionally, it includes built-in support for high availability and horizontal scaling, making it a reliable choice for large-scale applications.

MongoDB is a database that stores data in collections without requiring a schema to be defined beforehand, unlike in a relational database where you need to define tables. The structure of each collection can also be modified over time, making it easy to iterate your data model.

## Transaction

The transaction feature from relational databases, such as PostgreSQL, is natively supported and used by ROQ's generated application. However, the transaction feature is not supported in NoSQL databases like MongoDB. MongoDB only allows to start a transaction on a [replica set](https://www.mongodb.com/docs/manual/replication/). 

ROQ using Prisma to connect the database and Prisma uses transactions internally to avoid partial writes on nested queries. This means Prisma inherit the requirement of [needing](https://www.prisma.io/docs/concepts/database-connectors/mongodb#replica-set-configuration) a replica set configured. 

<Callout type="warning">
If you have a standalone MongoDB installation, you need to configure and run a replica set for the ROQ's generated application to work properly.
</Callout>

## MongoDB Atlas

[MongoDB Atlas](https://www.mongodb.com/atlas) is a fully managed cloud service provided by MongoDB, Inc. It offers all the features of MongoDB without the operational overhead of setting up and maintaining on-premises or cloud infrastructure. The database supports the replica set feature by default.

<Steps>
### Create Database

Create [a new account](https://account.mongodb.com/account/register) on MongoDB Atlas and create a new project. From the **Deployment** section click the **Database** menu. To create database click the **Build a Database**.

![MongoDB Atlas](/mongodb-atlas-new-project.png)

MongoDB Atlas also provides free database for the development purposes. We can upgrade it to production cluster anytime. When creating the database, select the **M0 Free** option and leave all other settings as default.

![new mongodb database](/mongodb-atlas-db.png)

### Create User

To access the database, we need a user. Go to the **Security** section, select **Quickstart**. Choose **Username and Password** for authentication. Then, set a secure username and password and save the password securely. After that click the **Create User** button. 

![mongod db atlas create user and password](/mongodb-atlas-user.png)

### IP Whitelist

To enable access from outside networks, such as local environments, we can configure specific IPs. For worldwide access, we can set it to **0.0.0.0/0**. However, this is not recommended for production purposes.
 
![mongodb ip whitelist](/mongodb-atlas-ips.png)

### `DATABASE_URL`

From the MongoDB Atlas **Overview**, we can get the database connection information. There are many ways to connect to the database, we can use MongoDB native drivers or using tools such as Compass, Shell, MongoDB for VS Code, etc. We will use the connection information using drivers.

![mongodb connection information](/mongodb-atlas-connection.png)

From MongoDB Atlas, we can copy the connection URI and add the initial database for our application, e.g., `animefigure`. Then, we can set the `DATABASE_URL` environment variable.

```shell
DATABASE_URL=mongodb+srv://postgres:<password>@cluster0.thmzdtv.mongodb.net/animefigure?retryWrites=true&w=majority
```
Please don't forget to update the password we set earlier. Later we need to add this `DATABASE_URL` environment variable into the `.env` file on the project root of our application.

</Steps>

## Prisma Schema Conversion

The default application generated by ROQ uses PostgreSQL as its database. If we want to switch to another database such as MongoDB, we need to configure the prisma schema file, located at `prisma\schema.prisma`.

<Callout type="info">
Learn more about here about [Prisma Schema](https://www.prisma.io/docs/concepts/components/prisma-schema) documentation and this [Prisma documentation](https://www.prisma.io/docs/guides/database/mongodb) explains the commonalities and differences between MongoDB and other database providers.
</Callout>

MongoDB's document-based structure and flexible schemas means that using Prisma with MongoDB differs from using it with a relational database in a number of ways. 

### Data Sources

This is the schema data source for the PostgreSQL database:

```js
datasource db {
  provider    = "postgresql"
  url         = env("DATABASE_URL")
  extensions  = [pgcrypto]
}
``` 

The changes to the database require updating Prisma's datasources to MongoDB and removing extension support.

```js
datasource db {
  provider    = "mongodb"
  url         = env("DATABASE_URL")
}
```

### Generators

Since MongoDB doesn't support extension, we should remove any of it.

<Tabs items={["MongoDB", "PostgreSQL"]}>
<Tab>
```js
generator client {
  provider = "prisma-client-js"
  previewFeatures = ["clientExtensions"]
}
```
</Tab>
<Tab>
```js
generator client {
  provider = "prisma-client-js"
  previewFeatures = ["clientExtensions", "postgresqlExtensions"]
}
```
</Tab>
</Tabs>

### Data Model

For example, we cannot reuse the existing Prisma schema without any changes especially in defining ID. Prisma does not support fields starting with `_`, that is common in MongoDB, so this needs to be mapped to a Prisma field using the `@map` attribute.

This code is a piece of PostgreSQL Prisma schema from a typical ROQ generated application:

```js
id       String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
user_id  String?  @db.Uuid
```
To change the schema for MongoDB database we need to maps the Prisma `id` field to the `_id` column in the database, `@map("_id")` and specifies that this field uses the `ObjectId` type in the database `@db.ObjectId`. The Prisma schema after conversion is like this:

```js
id       String   @id @default(auto()) @map("_id") @db.ObjectId
user_id  String?  @db.ObjectId
```



<Callout type="info">
For more information about Prisma schema data model, please read their official documentation [here](https://www.prisma.io/docs/concepts/components/prisma-schema/data-model) and the native type mapping from Prisma to MongoDB [here](https://www.prisma.io/docs/concepts/database-connectors/mongodb).
</Callout>

Here are the full examples of Prisma schemas for MongoDB and PostgreSQL databases. The MongoDB schema has been converted from the PostgreSQL schema:

<Tabs items={['Prisma Schema MongoDB', 'Prisma Schema PostgreSQL']}>
<Tab>
```js
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["clientExtensions"]
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

model collector_profile {
  id              String   @id @default(auto()) @map("_id") @db.ObjectId
  user_id         String?  @db.ObjectId
  collection_list String?
  wish_list       String?
  created_at      DateTime @default(now())
  updated_at      DateTime @default(now())
  user            user?    @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model discussion_board {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  topic      String
  user_id    String?  @db.ObjectId
  created_at DateTime @default(now())
  updated_at DateTime @default(now())
  user       user?    @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model figure_inventory {
  id               String             @id @default(auto()) @map("_id") @db.ObjectId
  figure_name      String
  store_id         String?            @db.ObjectId
  created_at       DateTime           @default(now())
  updated_at       DateTime           @default(now())
  store            store?             @relation(fields: [store_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  purchase_history purchase_history[]
  sales_analytics  sales_analytics[]
}

model purchase_history {
  id               String            @id @default(auto()) @map("_id") @db.ObjectId
  user_id          String?           @db.ObjectId
  figure_id        String?           @db.ObjectId
  purchase_date    DateTime
  created_at       DateTime          @default(now())
  updated_at       DateTime          @default(now())
  figure_inventory figure_inventory? @relation(fields: [figure_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  user             user?             @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model sales_analytics {
  id               String            @id @default(auto()) @map("_id") @db.ObjectId
  store_id         String?           @db.ObjectId
  figure_id        String?           @db.ObjectId
  sales_count      Int
  created_at       DateTime          @default(now())
  updated_at       DateTime          @default(now())
  figure_inventory figure_inventory? @relation(fields: [figure_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  store            store?            @relation(fields: [store_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model store {
  id               String             @id @default(auto()) @map("_id") @db.ObjectId
  description      String?
  name             String
  created_at       DateTime           @default(now())
  updated_at       DateTime           @default(now())
  user_id          String             @db.ObjectId
  tenant_id        String
  user             user               @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  figure_inventory figure_inventory[]
  sales_analytics  sales_analytics[]
}

model user {
  id                String              @id @default(auto()) @map("_id") @db.ObjectId
  email             String              @unique
  firstName         String?
  lastName          String?
  roq_user_id       String
  tenant_id         String
  created_at        DateTime            @default(now())
  updated_at        DateTime            @default(now())
  collector_profile collector_profile[]
  discussion_board  discussion_board[]
  purchase_history  purchase_history[]
  store             store[]
}
```
</Tab>
<Tab>

```js
generator client {
  provider = "prisma-client-js"
  previewFeatures = ["clientExtensions", "postgresqlExtensions"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  extensions      = [pgcrypto]
}

model collector_profile {
  id              String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id         String?  @db.Uuid
  collection_list String?  @db.VarChar(255)
  wish_list       String?  @db.VarChar(255)
  created_at      DateTime @default(now()) @db.Timestamp(6)
  updated_at      DateTime @default(now()) @db.Timestamp(6)
  user            user?    @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model discussion_board {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  topic      String   @db.VarChar(255)
  user_id    String?  @db.Uuid
  created_at DateTime @default(now()) @db.Timestamp(6)
  updated_at DateTime @default(now()) @db.Timestamp(6)
  user       user?    @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model figure_inventory {
  id               String             @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  figure_name      String             @db.VarChar(255)
  store_id         String?            @db.Uuid
  created_at       DateTime           @default(now()) @db.Timestamp(6)
  updated_at       DateTime           @default(now()) @db.Timestamp(6)
  store            store?             @relation(fields: [store_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  purchase_history purchase_history[]
  sales_analytics  sales_analytics[]
}

model purchase_history {
  id               String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id          String?           @db.Uuid
  figure_id        String?           @db.Uuid
  purchase_date    DateTime          @db.Date
  created_at       DateTime          @default(now()) @db.Timestamp(6)
  updated_at       DateTime          @default(now()) @db.Timestamp(6)
  figure_inventory figure_inventory? @relation(fields: [figure_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  user             user?             @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model sales_analytics {
  id               String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  store_id         String?           @db.Uuid
  figure_id        String?           @db.Uuid
  sales_count      Int
  created_at       DateTime          @default(now()) @db.Timestamp(6)
  updated_at       DateTime          @default(now()) @db.Timestamp(6)
  figure_inventory figure_inventory? @relation(fields: [figure_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  store            store?            @relation(fields: [store_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model store {
  id               String             @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  description      String?            @db.VarChar(255)
  name             String             @db.VarChar(255)
  created_at       DateTime           @default(now()) @db.Timestamp(6)
  updated_at       DateTime           @default(now()) @db.Timestamp(6)
  user_id          String             @db.Uuid
  tenant_id        String             @db.VarChar(255)
  figure_inventory figure_inventory[]
  sales_analytics  sales_analytics[]
  user             user               @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model user {
  id                String              @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  email             String              @unique @db.VarChar(255)
  firstName         String?             @db.VarChar(255)
  lastName          String?             @db.VarChar(255)
  roq_user_id       String              @db.VarChar(255)
  tenant_id         String              @db.VarChar(255)
  created_at        DateTime            @default(now()) @db.Timestamp(6)
  updated_at        DateTime            @default(now()) @db.Timestamp(6)
  collector_profile collector_profile[]
  discussion_board  discussion_board[]
  purchase_history  purchase_history[]
  store             store[]
}
```
</Tab>
</Tabs>

Because of the Prisma changes, we should regenerate it to updates the Prisma Client based on the Prisma schema (`schema.prisma`). The Prisma Client will provides update to a set of CRUD (Create, Read, Update, Delete) operations for the models defined in the schema.

```shell
npx prisma regenerate
```

## Prisma `db push`

The Prisma CLI has a dedicated command for prototyping schemas: `db push`. This command uses the same engine as [Prisma Migrate](
https://www.prisma.io/docs/concepts/components/prisma-migrate) to synchronize the Prisma schema with MongoDB database. For more information about `db push`. Please read the documentation [here](https://www.prisma.io/docs/concepts/components/prisma-migrate/db-push).

So instead of using the `prisma migrate` command, for MongoDB database we will use:

```shell
npx prisma db push
```

The above command will synchronize MongoDB with our Prisma schema. Also remember to set the `DATABASE_URL` in the `.env` file.




{/* Local database needs a replica set feature because ROQ needs transaction support.

To install MongoDB in your operating system, please follow the documentation below:

## Windows 

MongoDB provides many licensing type and package for installation: There are **msi** and **zip** packages, depends on the situation and how familiar you are with Windows OS.

### Installation

In this documentation we will use MongoDB Community edition with **msi** package, that can be downloaded [here](https://www.mongodb.com/try/download/community).

![mongodb windows install](/mongodb-windows-install.png)

By default this installation will also install the [MongoDB Compass](https://www.mongodb.com/products/tools/compass), which is a MongoDB GUI for querying and analyzing MongoDB data. You can, of course choose not to install it and leave everything at it's default.

MongoDB is installed as a Windows service for the network service user by default on Windows. We will later create a database for our application and set up a new username and password.

![mongodb install default](/mongodb-install-2.png)

For development purpose the basic installation is enough. If you not install MongoDB Compass then you'll need [MongoDB Shell](https://www.mongodb.com/docs/mongodb-shell/).

<Callout type="info">
MongoDB Shell is a modern and extensible command-line interface with syntax highlighting, autocomplete, help, and error messages.
</Callout>

Download the MongoDB Shell **zip** package from [here](https://www.mongodb.com/try/download/shell) and unzip it into the MongoDB installation:

 ```shell
 C:\Program Files\MongoDB\Server\7.0\bin
``` 

#### Add MongoDB to Environment

The MongoDB for Windows doesn't automatically set MongoDB `bin` folder into the environment path (so you can use it later in the terminal). 

To solve this problem you can include the MongoDB `bin` folder in the user environment using the Environment Variables Windows editor.

<Callout type="info">
You can open the Environment Variables Windows editor by typing `sysdm.cpl` in the terminal, then in the dialog, click the **Advanced** tab ➔ **Environment Variables** button.
</Callout>


![add mongodb to env](/mongodb-shell-env.png)

By adding MongoDB to the user environment path, you will be able to access it through the CLI.

### Create Database

In this section, we will walk you through the process of creating a single database for your ROQ application. For example, we will create a new database `animefigure` that will act as the primary data store for the generated application's data.

Connect to MongoDB server using MongoDB Shell:

```shell
mongosh
```
The server is currently running as a Windows service. However, please note that the default configuration of the server does not enable access control for the database. This means that read and write access to data and configuration is currently unrestricted.

To create `animefigure` database from MongoDB Shell:

```shell
use animefigure
```

The best practice is create a new user with read write permission for this specific database.     

```shell
 db.createUser({ 
	user: "roq", 
	pwd: "developm3nt", 
	roles: [ { role: "readWrite", db: "animefigure" }] 
})
```

From the setup above we can form the MongoDB URL:

```shell
mongodb://roq:developm3nt@localhost:27017/animefigure
```


### `DATABASE_URL`

The last step is to replace the `DATABASE_URL` environment variable in the `.env` file with the PostgreSQL local URL:

```ini
#.env
DATABASE_URL=mongodb://roq:developm3nt@localhost:27017/animefigure
```

And we should restart the application to pick up any changes on the `.env` file.

<Callout type="info">
To run the generated application for local development please read this [documentation](/development-guides/generated-applications/run-local-development).
</Callout>


## Ubuntu Linux

### Installation

To install MongoDB on Ubuntu variant, please read the official [documentation](https://www.mongodb.com/docs/manual/tutorial/install-mongodb-on-ubuntu/).

### Create Database


### `DATABASE_URL`


## Docker



## Prisma Schema Conversion

*/}